Software Engineering Simulator
======

## Group Project for CS4098 - Team Crab

In which you are a production manager in charge of various global software teams and you must try to complete your product with maximal cost efficiency.

## Requirements:
The project uses python 2.7 to run. The following packages are required and can be installed via apt:
* python-pygame
* python-nose
* python-pip

The following can be installed using pip:
* pgu

While it is not required for running the game, installing "timidity" through apt will remove the "No sound card" message 
that some players receive at the start of the game.

## Building, installing and everything in-between

The Makefile in the root of the project provides all functionality for building, testing and installing the project.
The file provides the following targets:

* build
* test
* clean
* install
* uninstall

The build target compiles each of the .py source files in the src directory into corresponding .pyc files in the bin 
directory (it will create the bin directory first if it does not already exist). The built project can then be run locally
via the command "./bin/SESimulator.pyc".

The test target will build the project as outlined above and then perform the unit tests which are in the test directory.
At the moment there are no tests since the project is only at a zero velocity release, so this target will perform the
same function as build for the time being.

The clean target deletes all the files in the bin directory.

The install target will first build the project (using the build target). It will then copy all the .pyc files in the 
bin directory into /opt/SESimulator_$(version). The inclusion of the version in the directory will allow for multiple
versions of the game to be installed alongside one another. So, for example release RC1_rc3 of the game will install
to the directory /opt/SESimulator\_RC1\_rc3/. Next, the script SESimulator.sh in the src directory will be copied into
/usr/local/bin/ so that users on the machine can start the simulator simply by using the command "SESimulator". Root
access is required to add files to opt/ and /usr/local/bin.

Once the game has been installed, it can be run using the command "SESimulator" as mentioned above. This command
can take an optional argument "--simv version" to specify which version of the game should be run (if there are
multiple versions installed). If this flag is not specified then the script will load the newest version of the
game to be installed.

The uninstall target simply removes all SESimulator files from /opt and /usr/local/bin. It will only uninstall
the version of the game that this source tree contains.

## Writing unit tests
The following is a simple example of the form a unit test should take in the test directory

```python
import importme
import unittest

class TestEngine(unittest.TestCase):

    def setUp(self):
        pass

    def test_method(self):
        pass

if __name__ == '__main__':
    unittest.main()
```

Each test directory contains an importme.py file. This must be imported at the start of each unit test. This allows
the test to see the modules contained in the bin directory at the root of the project.

Each file must contain a class which inherits from unittest.TestCase as shown. This provides a whole bunch of features
provided by the Python unittest framework. The setUp function must be provided to initialize any values required by each
test in this class. Every method that is a unittest must begin with "test_"

## Documentation
Documentation is generated by Pydoc. 
```python
def function():
    """Documentation Comment"""
    Code
```
to generate html documentation use
``` pydoc -w Module.file ```


## Inspection of Features
1. Feature #17 - Master configuration file
  * The master configuration file is just a Python file which is interpreted by the game, kept in global_config.py. It contains a dictionary of key/value pairs for configuration values.
2. Feature #9 - Process simulator
  * Simply start the game with the sample game file (this happens automatically at the moment).
  * Output from the process simulator will automatically be displayed in the console every game hour as each task progresses
  * This output is of the form "Module: module\_name Task: task\_name - Actual Progress: x - expected Progress: y" where x and y are floating point values.
  * The time at GMT is also printed on each turn, it is shown as a 24 hour clock in the form "[hours, minutes]".
3. Feature #6 - Status display
  * Once the program is launched with a selected senario, the status screen is shown.
  * Green represents sites that are on schedule
  * Yellow represents sites that have been delayed
  * Red represents sites that have been stalled and need an intervention to progress any further
  * Grey represents sites that are inactive - waiting on a dependency or completed.
  * Sites are clickable to view more detailed information about a site.
4. Feature #20 - Default scenarios
  * Scenarios can be loaded from the command line using the -l and --load flags. As it stands there are two default scenarios available.
  * As an example, run 'SESimulator -l scenario2' to load scenario2.
  * A list of available scenarios can be found by listing the contents of the src/games directory.
5. Feature #14 - End of game report 
  * Start the game with the sample game file (this happens automatically at the moment).
  * Wait until the end of the game.
  * A summary of the report will be displayed on the screen, with the full report written to report.csv in the game's working directory.

##Attributions:
* Map Image - http://dezignus.com/vector-world-map/#more-912
* Man Icon - Man by Tamiko Young from The Noun Project http://thenounproject.com/term/man/12173/
* Gear Icon - Gear by Reed Enger from The Noun Project
* Clock Icon - Clock by Nicholas Burroughs from The Noun Project
* Target Icon - Target by Laurent Patain from The Noun Project 
* Location Icon - Designed by Vladimir Dubinin from the Noun Project


